1. 背景：DSP人群包数据目前key是didmd5，如果新增一种广告主/版本号，内存空间需要成倍增加，故需设计一种新的数据结构解决满足内存也满足业务DSP高性能
2. 问题：现在有数据结构不满足业务扩展的需要，扩展会造成极大的成本提高，同时更新数据极期复杂

3. 现状:
	3.1 数据结构 key-value 
		key：{version}_{device_id_md5}			// string 类型
		Value：只有两种状态，数据存在/不存在	// string 类型	
	3.2 业务数据case
		还呗-（didMd51--1：投，0：不投）
		微业贷- （didMd52--1：投，0：不投）
		redis目标人群包结构功能说明：
		{
			didMd51:0		// 还呗该设备不投放
			didMd52:1		// 微业贷该设备投放
		}

4. 设计要求
	4.1 支持高并发读（写入应该不频繁）
	4.2 所有推送的广告主之间不可以相互覆盖（如A上传广告主a，B上传广告主b，他们不覆盖）
	4.3 支持多广告主之间降低耦合度，可以自由扩展广告主

5. 新方案设计
	5.1 数据结构：key-value 
		key: 广告主ID+分片ID+版本号，分片ID用于解决单个bitmap限制2^31(20亿/512M)，版本号可选看业务需要		// string 类型
		value: 人群设备号对应的bitmap，设备号ID为偏移量offset，如果有业务功能则为1，没有则为0				// bitmap 形式

	5.2 业务数据例子
		例如转换后的设备ID为8，还呗不投放，微业贷投放
		redis目标人群包结构功能说明：
		{
			huanbei_part1_0:000000000000010.....						// 还呗该设备不投放，value 的offset=8为0
			weiyedai_part1_0:00000001100010.....						// 微业贷该设备投放，value 的offset=8为1
		}
	优点：
		1. 大量节省空间：单广告主30亿数据总存储量为：2*512M=1G，对于新增广告主最大增加1G空间，远低于原来100+g空间
		2. 减少因更新带来的频繁IO操作：新增和删除广告主仅需要离线计算生成bitmap，然后更改一个key，避免因key是设备ID频繁读写redis
		3. 业务上可以保留版本号
	缺点：
		1. 需要把设备号转换成相应的bitmap
		2. 设计设备号转换为offset偏移方案，满足在线转换需求
		3. DSP读时先进行一次设备号转换内存操作，然后再使用 getbit key offset 命令查询bitmap，耗时待评估
		
